"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var type_1 = require("vega-lite/build/src/type");
var property_1 = require("./property");
var wildcard_1 = require("./wildcard");
var wildcardindex_1 = require("./wildcardindex");
var spec_1 = require("./query/spec");
var encoding_1 = require("./query/encoding");
var groupby_1 = require("./query/groupby");
var shorthand_1 = require("./query/shorthand");
var util_1 = require("./util");
var util_2 = require("datalib/src/util");
var nest_1 = require("./nest");
/**
 * Internal class for specQuery that provides helper for the enumeration process.
 */
var SpecQueryModel = /** @class */ (function () {
    function SpecQueryModel(spec, wildcardIndex, schema, opt, wildcardAssignment) {
        this._rankingScore = {};
        this._spec = spec;
        this._channelFieldCount = spec.encodings.reduce(function (m, encQ) {
            if (!wildcard_1.isWildcard(encQ.channel) && (!encoding_1.isAutoCountQuery(encQ) || encQ.autoCount !== false)) {
                m[encQ.channel + ''] = 1;
            }
            return m;
        }, {});
        this._wildcardIndex = wildcardIndex;
        this._assignedWildcardIndex = wildcardAssignment;
        this._opt = opt;
        this._schema = schema;
    }
    /**
     * Build an WildcardIndex by detecting enumeration specifiers
     * in the input specQuery and replace short wildcards with
     * full ones that includes both names and enumValues.
     *
     * @return a SpecQueryModel that wraps the specQuery and the WildcardIndex.
     */
    SpecQueryModel.build = function (specQ, schema, opt) {
        var wildcardIndex = new wildcardindex_1.WildcardIndex();
        // mark
        if (wildcard_1.isWildcard(specQ.mark)) {
            var name_1 = wildcard_1.getDefaultName(property_1.Property.MARK);
            specQ.mark = wildcard_1.initWildcard(specQ.mark, name_1, opt.enum.mark);
            wildcardIndex.setMark(specQ.mark);
        }
        // TODO: transform
        // encodings
        specQ.encodings.forEach(function (encQ, index) {
            if (encoding_1.isAutoCountQuery(encQ)) {
                // This is only for testing purpose
                console.warn('A field with autoCount should not be included as autoCount meant to be an internal object.');
                encQ.type = type_1.Type.QUANTITATIVE; // autoCount is always quantitative
            }
            if (encoding_1.isFieldQuery(encQ) && encQ.type === undefined) {
                // type is optional -- we automatically augment wildcard if not specified
                encQ.type = wildcard_1.SHORT_WILDCARD;
            }
            // For each property of the encodingQuery, enumerate
            property_1.ENCODING_TOPLEVEL_PROPS.forEach(function (prop) {
                if (wildcard_1.isWildcard(encQ[prop])) {
                    // Assign default wildcard name and enum values.
                    var defaultWildcardName = wildcard_1.getDefaultName(prop) + index;
                    var defaultEnumValues = wildcard_1.getDefaultEnumValues(prop, schema, opt);
                    var wildcard = encQ[prop] = wildcard_1.initWildcard(encQ[prop], defaultWildcardName, defaultEnumValues);
                    // Add index of the encoding mapping to the property's wildcard index.
                    wildcardIndex.setEncodingProperty(index, prop, wildcard);
                }
            });
            // For each nested property of the encoding query  (e.g., encQ.bin.maxbins)
            property_1.ENCODING_NESTED_PROPS.forEach(function (prop) {
                var propObj = encQ[prop.parent]; // the property object e.g., encQ.bin
                if (propObj) {
                    var child = prop.child;
                    if (wildcard_1.isWildcard(propObj[child])) {
                        // Assign default wildcard name and enum values.
                        var defaultWildcardName = wildcard_1.getDefaultName(prop) + index;
                        var defaultEnumValues = wildcard_1.getDefaultEnumValues(prop, schema, opt);
                        var wildcard = propObj[child] = wildcard_1.initWildcard(propObj[child], defaultWildcardName, defaultEnumValues);
                        // Add index of the encoding mapping to the property's wildcard index.
                        wildcardIndex.setEncodingProperty(index, prop, wildcard);
                    }
                }
            });
        });
        // AUTO COUNT
        // Add Auto Count Field
        if (opt.autoAddCount) {
            var channel = {
                name: wildcard_1.getDefaultName(property_1.Property.CHANNEL) + specQ.encodings.length,
                enum: wildcard_1.getDefaultEnumValues(property_1.Property.CHANNEL, schema, opt)
            };
            var autoCount = {
                name: wildcard_1.getDefaultName(property_1.Property.AUTOCOUNT) + specQ.encodings.length,
                enum: [false, true]
            };
            var countEncQ = {
                channel: channel,
                autoCount: autoCount,
                type: type_1.Type.QUANTITATIVE
            };
            specQ.encodings.push(countEncQ);
            var index = specQ.encodings.length - 1;
            // Add index of the encoding mapping to the property's wildcard index.
            wildcardIndex.setEncodingProperty(index, property_1.Property.CHANNEL, channel);
            wildcardIndex.setEncodingProperty(index, property_1.Property.AUTOCOUNT, autoCount);
        }
        return new SpecQueryModel(specQ, wildcardIndex, schema, opt, {});
    };
    Object.defineProperty(SpecQueryModel.prototype, "wildcardIndex", {
        get: function () {
            return this._wildcardIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecQueryModel.prototype, "schema", {
        get: function () {
            return this._schema;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecQueryModel.prototype, "specQuery", {
        get: function () {
            return this._spec;
        },
        enumerable: true,
        configurable: true
    });
    SpecQueryModel.prototype.duplicate = function () {
        return new SpecQueryModel(util_1.duplicate(this._spec), this._wildcardIndex, this._schema, this._opt, util_1.duplicate(this._assignedWildcardIndex));
    };
    SpecQueryModel.prototype.setMark = function (mark) {
        var name = this._wildcardIndex.mark.name;
        this._assignedWildcardIndex[name] = this._spec.mark = mark;
    };
    SpecQueryModel.prototype.resetMark = function () {
        var wildcard = this._spec.mark = this._wildcardIndex.mark;
        delete this._assignedWildcardIndex[wildcard.name];
    };
    SpecQueryModel.prototype.getMark = function () {
        return this._spec.mark;
    };
    SpecQueryModel.prototype.getEncodingProperty = function (index, prop) {
        var encQ = this._spec.encodings[index];
        if (property_1.isEncodingNestedProp(prop)) {
            return encQ[prop.parent][prop.child];
        }
        return encQ[prop]; // encoding property (non-nested)
    };
    SpecQueryModel.prototype.setEncodingProperty = function (index, prop, value, wildcard) {
        var encQ = this._spec.encodings[index];
        if (prop === property_1.Property.CHANNEL && encQ.channel && !wildcard_1.isWildcard(encQ.channel)) {
            // If there is an old channel
            this._channelFieldCount[encQ.channel]--;
        }
        if (property_1.isEncodingNestedProp(prop)) {
            encQ[prop.parent][prop.child] = value;
        }
        else if (property_1.hasNestedProperty(prop) && value === true) {
            encQ[prop] = util_1.extend({}, encQ[prop], // copy all existing properties
            { enum: undefined, name: undefined } // except name and values to it no longer an wildcard
            );
        }
        else {
            encQ[prop] = value;
        }
        this._assignedWildcardIndex[wildcard.name] = value;
        if (prop === property_1.Property.CHANNEL) {
            // If there is a new channel, make sure it exists and add it to the count.
            this._channelFieldCount[value] = (this._channelFieldCount[value] || 0) + 1;
        }
    };
    SpecQueryModel.prototype.resetEncodingProperty = function (index, prop, wildcard) {
        var encQ = this._spec.encodings[index];
        if (prop === property_1.Property.CHANNEL) {
            this._channelFieldCount[encQ.channel]--;
        }
        // reset it to wildcard
        if (property_1.isEncodingNestedProp(prop)) {
            encQ[prop.parent][prop.child] = wildcard;
        }
        else {
            encQ[prop] = wildcard;
        }
        // add remove value that is reset from the assignment map
        delete this._assignedWildcardIndex[wildcard.name];
    };
    SpecQueryModel.prototype.channelUsed = function (channel) {
        // do not include encoding that has autoCount = false because it is not a part of the output spec.
        return this._channelFieldCount[channel] > 0;
    };
    SpecQueryModel.prototype.stack = function () {
        return spec_1.stack(this._spec);
    };
    SpecQueryModel.prototype.getEncodings = function () {
        // do not include encoding that has autoCount = false because it is not a part of the output spec.
        return this._spec.encodings.filter(function (encQ) { return !encoding_1.isDisabledAutoCountQuery(encQ); });
    };
    SpecQueryModel.prototype.getEncodingQueryByChannel = function (channel) {
        for (var _i = 0, _a = this._spec.encodings; _i < _a.length; _i++) {
            var specEncoding = _a[_i];
            if (specEncoding.channel === channel) {
                return specEncoding;
            }
        }
        return undefined;
    };
    SpecQueryModel.prototype.getEncodingQueryByIndex = function (i) {
        return this._spec.encodings[i];
    };
    SpecQueryModel.prototype.isAggregate = function () {
        return spec_1.isAggregate(this._spec);
    };
    SpecQueryModel.prototype.toShorthand = function (groupBy) {
        if (groupBy) {
            if (util_2.isString(groupBy)) {
                return nest_1.getGroupByKey(this.specQuery, groupBy);
            }
            var parsedGroupBy = groupby_1.parseGroupBy(groupBy);
            return shorthand_1.spec(this._spec, parsedGroupBy.include, parsedGroupBy.replacer);
        }
        return shorthand_1.spec(this._spec);
    };
    SpecQueryModel.prototype._encoding = function () {
        var encoding = {};
        for (var _i = 0, _a = this._spec.encodings; _i < _a.length; _i++) {
            var encQ = _a[_i];
            // Need to cast here so we can assign properties later
            var fieldDef = {};
            // For count field that is automatically added, convert to correct vega-lite fieldDef
            if (encoding_1.isEnabledAutoCountQuery(encQ)) {
                fieldDef = {
                    aggregate: 'count',
                    field: '*',
                    type: 'quantitative'
                };
            }
            else if (encoding_1.isValueQuery(encQ) || encoding_1.isDisabledAutoCountQuery(encQ)) {
                continue; // Do not include this in the output.
            }
            // if channel is a wildcard, return null
            if (wildcard_1.isWildcard(encQ.channel))
                return null;
            // assemble other property into a field def.
            var PROPERTIES = [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.FIELD, property_1.Property.TYPE, property_1.Property.SCALE, property_1.Property.SORT, property_1.Property.AXIS, property_1.Property.LEGEND];
            for (var _b = 0, PROPERTIES_1 = PROPERTIES; _b < PROPERTIES_1.length; _b++) {
                var prop = PROPERTIES_1[_b];
                // if the property's a wildcard, return null
                var encodingProperty = encQ[prop];
                if (wildcard_1.isWildcard(encodingProperty)) {
                    return null;
                }
                else {
                    // all channels support this prop
                    var isSupportedByChannel = (!shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop] || shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop][encQ.channel]);
                    if (isSupportedByChannel) {
                        if (encodingProperty !== undefined) {
                            if (property_1.ENCODING_NESTED_PROP_PARENT_INDEX[prop]) {
                                for (var childProp in encQ[prop]) {
                                    // ensure nested properties are not wildcard before assigning to field def
                                    if (wildcard_1.isWildcard(encQ[prop][childProp])) {
                                        return null;
                                    }
                                }
                            }
                            fieldDef[prop] = encodingProperty;
                        }
                        if (prop === property_1.Property.SCALE && encoding_1.isFieldQuery(encQ) && encQ.type === type_1.Type.ORDINAL) {
                            var scale = encQ.scale;
                            var ordinalDomain = this._schema.fieldSchema(encQ.field).ordinalDomain;
                            if (scale !== null && ordinalDomain) {
                                fieldDef[property_1.Property.SCALE] = __assign({ domain: ordinalDomain }, (util_1.isObject(scale) ? scale : {}));
                            }
                        }
                    }
                }
            }
            if (fieldDef.bin === false) {
                // exclude bin false
                delete fieldDef.bin;
            }
            encoding[encQ.channel] = fieldDef;
        }
        return encoding;
    };
    /**
     * Convert a query to a Vega-Lite spec if it is completed.
     * @return a Vega-Lite spec if completed, null otherwise.
     */
    SpecQueryModel.prototype.toSpec = function (data) {
        if (wildcard_1.isWildcard(this._spec.mark))
            return null;
        var spec = {};
        data = data || this._spec.data;
        if (data) {
            spec.data = data;
        }
        if (this._spec.transform) {
            spec.transform = this._spec.transform;
        }
        spec.mark = this._spec.mark;
        spec.encoding = this._encoding();
        if (spec.encoding === null) {
            return null;
        }
        if (this._spec.config || this._opt.defaultSpecConfig)
            spec.config = util_1.extend({}, this._opt.defaultSpecConfig, this._spec.config);
        return spec;
    };
    SpecQueryModel.prototype.getRankingScore = function (rankingName) {
        return this._rankingScore[rankingName];
    };
    SpecQueryModel.prototype.setRankingScore = function (rankingName, score) {
        this._rankingScore[rankingName] = score;
    };
    return SpecQueryModel;
}());
exports.SpecQueryModel = SpecQueryModel;
function getTopSpecQueryItem(specQuery) {
    var topItem = specQuery.items[0];
    while (topItem && isSpecQueryGroup(topItem)) {
        topItem = topItem.items[0];
    }
    return topItem;
}
exports.getTopSpecQueryItem = getTopSpecQueryItem;
function isSpecQueryGroup(item) {
    return item.items !== undefined;
}
exports.isSpecQueryGroup = isSpecQueryGroup;
//# sourceMappingURL=model.js.map