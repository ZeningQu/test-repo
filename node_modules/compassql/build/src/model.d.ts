import { Channel } from 'vega-lite/build/src/channel';
import { Data } from 'vega-lite/build/src/data';
import { Mark } from 'vega-lite/build/src/mark';
import { FacetedCompositeUnitSpec } from 'vega-lite/build/src/spec';
import { StackProperties } from 'vega-lite/build/src/stack';
import { QueryConfig } from './config';
import { Property } from './property';
import { Wildcard } from './wildcard';
import { WildcardIndex } from './wildcardindex';
import { SpecQuery } from './query/spec';
import { EncodingQuery } from './query/encoding';
import { GroupBy, ExtendedGroupBy } from './query/groupby';
import { RankingScore } from './ranking/ranking';
import { Schema } from './schema';
import { Dict } from './util';
/**
 * Internal class for specQuery that provides helper for the enumeration process.
 */
export declare class SpecQueryModel {
    private _spec;
    /** channel => EncodingQuery */
    private _channelFieldCount;
    private _wildcardIndex;
    private _assignedWildcardIndex;
    private _schema;
    private _opt;
    private _rankingScore;
    /**
     * Build an WildcardIndex by detecting enumeration specifiers
     * in the input specQuery and replace short wildcards with
     * full ones that includes both names and enumValues.
     *
     * @return a SpecQueryModel that wraps the specQuery and the WildcardIndex.
     */
    static build(specQ: SpecQuery, schema: Schema, opt: QueryConfig): SpecQueryModel;
    constructor(spec: SpecQuery, wildcardIndex: WildcardIndex, schema: Schema, opt: QueryConfig, wildcardAssignment: Dict<any>);
    readonly wildcardIndex: WildcardIndex;
    readonly schema: Schema;
    readonly specQuery: SpecQuery;
    duplicate(): SpecQueryModel;
    setMark(mark: Mark): void;
    resetMark(): void;
    getMark(): "area" | "circle" | "line" | "rect" | "text" | "square" | "point" | "bar" | "tick" | "rule" | "?" | Wildcard<Mark>;
    getEncodingProperty(index: number, prop: Property): any;
    setEncodingProperty(index: number, prop: Property, value: any, wildcard: Wildcard<any>): void;
    resetEncodingProperty(index: number, prop: Property, wildcard: Wildcard<any>): void;
    channelUsed(channel: Channel): boolean;
    stack(): StackProperties;
    getEncodings(): EncodingQuery[];
    getEncodingQueryByChannel(channel: Channel): EncodingQuery;
    getEncodingQueryByIndex(i: number): EncodingQuery;
    isAggregate(): boolean;
    toShorthand(groupBy?: string | (string | ExtendedGroupBy)[]): string;
    private _encoding();
    /**
     * Convert a query to a Vega-Lite spec if it is completed.
     * @return a Vega-Lite spec if completed, null otherwise.
     */
    toSpec(data?: Data): FacetedCompositeUnitSpec;
    getRankingScore(rankingName: string): RankingScore;
    setRankingScore(rankingName: string, score: RankingScore): void;
}
export interface SpecQueryGroup<T> {
    name: string;
    path: string;
    items: (SpecQueryGroup<T> | T)[];
    groupBy?: GroupBy;
    orderGroupBy?: string | string[];
}
export declare function getTopSpecQueryItem<T>(specQuery: SpecQueryGroup<T>): T;
export declare function isSpecQueryGroup<T>(item: SpecQueryGroup<T> | T): item is SpecQueryGroup<T>;
export declare type SpecQueryModelGroup = SpecQueryGroup<SpecQueryModel>;
